#!/bin/sh
#            == ft ==
#
# Use fzf to select tags interactively from the database generated by ft-updatedb.
# Then automatically copy the selected tags to the clipboard.
#
# ft is intended to be used in conjunction with your browser or image viewer of choice.
#
# If the first argument is '-s', then the final step of copying will be skipped.
# `ft -s` is intended for use with command substitutions in scripts, eg 'TAGS=$(ft -s)`
#
# Any other arguments passed to 'ft' will be passed on to 'fzf'.
#
# For example, you can reduce the number of terminal lines occupied by the fzf query like this:
#   `ft --height=10`
# (or via the FZF_DEFAULT_OPTS environment variable, which is documented in the fzf man page.)
#
#
# TODO:
#
#  * allow a list of tags that should be preselected to be passed in on stdin.
#



DB=~/.cache/e621-fzftags
AUTOCOPY=1
TAB="$(printf '\t')"
ESC="$(printf '\e')"
NEWLINE="$(printf '\n')"

# XXX local alias support aka 'quicktags'?

# XXX prompt user to build DB if it isn't found

if ! [ -f "$DB" ]; then
  echo "Missing database $DB. You need to generate it using 'updatedb'" 1>&2
  exit 1
fi

DB_NLINES=$(wc -l < "$DB")
if [ $DB_NLINES -lt 50 ]; then
  echo "Database $DB seems too small ($DB_NLINES items). Exiting." 1>&2
  exit 1
fi

while true; do
  case "$1" in
    -s ) AUTOCOPY=; shift 1;;
    --stdout ) AUTOCOPY=; shift 1;;
    --old-tags ) IFS=" $TAB";OLDTAGS="$2";unset IFS;shift 2;;
    * ) break
  esac
done

fzfsel ()
{
# XXX if the user adjusts preview window size, the
# '50% of terminal width' wrapping size will be wrong. Probably need to detect and parse it!
#
# Specific shell is enforced here because it's pretty difficult to write a command portable
# between sh/bash/zsh/fish/etc.
  COLS=$(tput cols)
  COLS=$(((COLS/2)-4))
  SHELL=/bin/sh

  if [ -f /bin/dash ]; then
    SHELL=/bin/dash
  fi

  IFS="$NEWLINE"
  # XXX won't work for items containing characters that need URL-escaping
  # eg /, <, >, &, ?
  #
  # It may be possible to hack something together with sed..
  ALTEBIND='--bind=alt-e:execute(xdg-open http://e621.net/wiki/show/{1}&)'
  TABBIND='--bind=tab:toggle+unix-line-discard+top'
  TIEBREAK='--tiebreak=begin'
  # approximate don't-override-defined-keybinding check.
  # Should not cause false negatives, but false positives are possible.
  #
  # you may want to override, for example if you want to use mimeo rather than xdg-open.
  if printf '%s\n' "$FZF_DEFAULT_OPTS" | grep -Ee 'bind.+alt-e:[^,]+' > /dev/null; then
    ALTEBIND=''
  fi

  if printf '%s\n' "$FZF_DEFAULT_OPTS" | grep -Ee 'bind.+tab:[^,]+' > /dev/null; then
    TABBIND=''
  fi

  if printf '%s\n' "$FZF_DEFAULT_OPTS" | grep -e '--tiebreak' > /dev/null; then
    TIEBREAK=''
  fi

  printf '' >  /tmp/fzfsel-oldtags
  printf '' >  /tmp/fzfsel-oldtags2
  PREVIEW="printf '%s\n' {+1} | sort | tr \\\n ' ' |fold -s -w $COLS"
#
  if [ -n "$OLDTAGS" ]; then
    IFS=" $TAB"
    printf '%s\n' $OLDTAGS > /tmp/fzfsel-oldtags
# width
    CWIDTH=$(head -1 ~/.cache/e621-fzftags |grep -Eboe "$TAB"'[0-9]')
    CWIDTH=${CWIDTH%%:*}
    CWIDTH=$((CWIDTH-1))
#    echo "CW $CWIDTH" 1>&2
    OLDTAGS=$(printf "\e[36m-%s\e[0m " $OLDTAGS)
    printf "%-$CWIDTH"'s\tx\n' $OLDTAGS  > /tmp/fzfsel-oldtags2
    PREVIEW="printf '%s\n' {+1} | cat /tmp/fzfsel-oldtags - | sort -u | tr \\\n ' ' |fold -s -w $COLS"
  fi

  IFS="$NEWLINE"
  cat $DB /tmp/fzfsel-oldtags2 | \
  fzf -m --ansi --nth 1 $TABBIND $ALTEBIND $TIEBREAK \
   --preview "$PREVIEW" \
   "$@" | cut -f 1 -d ' ' |tr \\n ' '
  unset IFS
}

stripcolor ()
{
  ESC="$(printf '\33')"
  sed -e "s,$ESC\[[0-9;]+m,,g"
}

applyuntags ()
{
  read TAGS
  NEWTAGS=
  NEG=
  NORMAL=
  #echo "before apply, $TAGS" 1>&2
  for T in $TAGS; do
    case "$T" in
     -* ) T=${T#-}
          if [ -n "$NEG" ]; then
            NEG="$NEG $T"
          else
            NEG="$T"
          fi;;
     * )  if [ -n "$NORMAL" ]; then
            NORMAL="$NORMAL $T"
          else
            NORMAL="$T"
          fi;;
    esac
  done;
  NEWTAGS=$(for T in $NORMAL; do
     if ! echo "$NEG" | fgrep -we "$T" > /dev/null; then
       printf '%s ' "$T"
     fi
   done)
  NEWTAGS="${NEWTAGS% }"
#  echo "after apply, $NEWTAGS" 1>&2
  echo "$NEWTAGS"
}

# xsel note:
#
# '-b' outputs to CLIPBOARD clipboard - the one used, for example, when you press Ctrl+C or Ctrl+V
#      in Firefox.
#
# if that isn't what you want, replace -b with:
#
# '-p' to output to PRIMARY clipboard (the one used when you highlight text in terminal or
#      middleclick to paste), or
#
# '-s' to output to SECONDARY clipboard (no idea what this is. Maybe KDE/Gnome use it?)
#

docopy ()
{
   if [ -n "$AUTOCOPY" ]; then
     xsel -i -b
   else
     cat -
   fi
}


TAGS=$(fzfsel "$@" | stripcolor)
TAGS=$(tr \\n ' ' < /tmp/fzfsel-oldtags)"$TAGS"
echo "$TAGS" | applyuntags | docopy

rm /tmp/fzfsel-oldtags /tmp/fzfsel-oldtags2
